<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Minor defaulted comparisons fixes</title>

<style type="text/css">
ins, ins > * { text-decoration:none; font-weight:bold; background-color:#A0FFA0 }
del, del > * { text-decoration:line-through; background-color:#FFA0A0 }

blockquote {
  color: #000000; background-color: #F1F1F1;
  border: 1px solid #D1D1D1;
  padding-left: 0.5em; padding-right: 0.5em;
}
blockquote.stdins {
  color: #000000; background-color: #C8FFC8;
  border: 1px solid #B3EBB3;
  padding-left: 0.5em; padding-right: 0.5em;
}
blockquote.stddel {
  text-decoration: line-through;
  color: #000000; background-color: #FFEBFF;
  border: 1px solid #ECD7EC;
  padding-left: 0.5em; padding-right: 0.5em;
}
</style>

</head>

<body>
Richard Smith<br>
2019-11-26

<p>
Change in 11.11.1 [class.compare.default] paragraph 1:
</p>

<blockquote>
A defaulted comparison operator function (12.6.2) for some class C shall be a non-template function declared
in the member-specification of C that is
<ul>
<li>
a non-static const member of C having one parameter of type const C&, or

<li>
a friend of C having either two parameters of type const C& or two parameters of type C.
</ul>
<ins>
A defaulted comparison operator function for class <tt>C</tt>
that is not defined as deleted
is <i>implicitly defined</i>
<!-- at the end of the definition of class <tt>C</tt>. -->
when it is odr-used or needed for constant evaluation.
Overload resolution is performed from a context equivalent to
the <i>function-body</i> of the defaulted <tt>operator@</tt> function,
except that the defaulted function itself is not a candidate.</ins>
</blockquote>

<i>Drafting note: the lazy definition of the defaulted function
needs to perform unqualified lookup for operator functions.
Such lookups should be done at the point where the function is defaulted,
in a manner analogous to two-phase name lookup for templates.
Lookups for a defaulted secondary operator function need to avoid
finding that secondary operator function itself.
</i>

<p>
Change in 11.11.1 [class.compare.default] paragraph 2:
</p>

<blockquote>
A defaulted <del>comparison</del> <ins><tt>&lt;=&gt;</tt> or <tt>==</tt></ins> operator function
for class <tt>C</tt>
is defined as deleted if
any non-static data member of <tt>C</tt> is of reference type or
<tt>C</tt> <del>is a union-like class</del> <ins>has variant members</ins> (11.5.1).
</blockquote>

<i>Drafting note: it is not necessary to consider members when defaulting
a secondary comparison operator (<tt>&lt;</tt>, <tt>&lt;=</tt>, ...)
in terms of a user-provided primary comparison operator.
Also, while variant members pose a problem for defaulted primary comparisons,
empty unions do not.</i>

<p>
Add a new paragraph after 11.11.1 [class.compare.default] paragraph 2:
</p>

<blockquote class="stdins">
A defaulted comparison function is <i>constexpr-compatible</i> if
it satisfies the requirements for a constexpr function ([dcl.constexpr])
and each comparison operator function invoked by its defaulted definition
is a constexpr function.
</blockquote>

<i>Drafting note: the implicit definition can invoke other functions, such as a conversion from
some custom comparison category to the return type. Ignoring those is consistent with
the rule we use for defaulted special member functions.</i>

<p>
Add a new paragraph to the end of 11.4.3 [special]:
</p>

<blockquote class="stdins">
A defaulted special member function is <i>constexpr-compatible</i> if
it the corresponding implicitly-declared special member function
would be a constexpr function.
</blockquote>

<p>
Change in 9.5.2 [dcl.fct.def.default] paragraph 3:
<p>

<blockquote>
An explicitly-defaulted function that is not defined as deleted
may be declared constexpr or consteval
only if it <del>would have been</del> <ins>is</ins> <del>implicitly declared as</del>
constexpr<ins>-compatible ([special], [class.compare.default])</ins>.
If a <ins>constexpr-compatible</ins> function is explicitly defaulted on its first declaration,
it is implicitly considered to be constexpr <del>if the implicit declaration would be</del>.
</blockquote>

<i>Drafting note: this behavior seems unwise; consider a case such as:</i>

<pre>
constexpr bool operator==(const X&, const X&);
struct X { int n; friend bool operator==(const X&, const X&) = default; };
</pre>

<i>This program is valid, but reversing the order of the two lines renders it ill-formed
because the defaulted <tt>operator==</tt> is no longer <tt>constexpr</tt>.
Perhaps a better rule would be that a constexpr-compatible defaulted function
is implicitly constexpr if it is defaulted at class scope, regardless of whether
that's the first declaration? The same concern applies to the implicit exception specification.
This also affects whether the function is considered to be user-provided,
which controls whether the program is ill-formed if the function is defined as deleted.</i>

<p>
Change in 11.11.1 [class.compare.default] paragraph 3:
</p>

<blockquote>
If the class definition does not explicitly declare an <tt>==</tt> operator function,
<del>but declares a defaulted three-way comparison operator function,</del>
an <tt>==</tt> operator function is declared implicitly
<ins>for each defaulted three-way comparison operator function
declared in the class definition,</ins>
with the same access <ins>and <i>function-definition</i>
and in the same class scope</ins>
as the three-way comparison operator function<ins>,
except that the return type is replaced with <tt>bool</tt>
and the <i>declarator-id</i> is replaced with <tt>operator==</tt></ins>.
<ins>[<i>Note</i>: Such an</ins>
<del>The</del> implicitly-declared <tt>==</tt> operator for a class <tt>X</tt>
is an inline <del>member</del> <ins>function</ins> and
is defined as defaulted in the definition of <tt>X</tt><ins>,
and has the same
<i>parameter-declaration-clause</i> and
trailing <i>requires-clause</i> as the three-way comparison operator</ins>.
If the three-way comparison operator function is declared as
a non-static const member, the implicitly-declared <tt>==</tt> operator function is a <ins>non-static const</ins> member<ins>.</ins>
<del>of the form
<pre>
bool X::operator==(const X&) const;
</pre>
Otherwise,
</del>
<ins>If the three-way comparison operator function declaration is a friend declaration,</ins>
the implicitly-declared <tt>==</tt> operator function is
<ins>a friend declaration.</ins>
<del>
of the form
<pre>
friend bool operator==(const X&, const X&);
</pre>
</del>
<del>[<i>Note</i>:</del> Such a friend function is visible to argument-dependent lookup only.
<ins>If the three-way comparison operator function is declared
<tt>virtual</tt>, <tt>constexpr</tt>, or <tt>consteval</tt>,
the implicitly-declared <tt>==</tt> operator function is declared
<tt>virtual</tt>, <tt>constexpr</tt>, or <tt>consteval</tt>,
respectively.</ins> &mdash;<i>end note</i>]
<ins>[<i>Example</i>:
<pre>
template&lt;typename T&gt; struct X {
  friend constexpr std::strong_ordering operator&lt;=&gt;(X, X) requires (sizeof(T) != 1) = default;
  // implicitly declares: friend constexpr bool operator==(X, X) requires (sizeof(T) != 1) = default;

  [[nodiscard]] virtual std::partial_ordering operator&lt;=&gt;(const X&amp;) const = default;
  // implicitly declares: [[nodiscard]] virtual bool operator==(const X&amp;) const = default;
};
</pre>
&mdash;<i>end example</i>]</ins>
<del>The operator is a <tt>constexpr</tt> function if its definition would satisfy the requirements for a <tt>constexpr</tt> function.</del>
[<i>Note</i>: The <tt>==</tt> operator function is declared implicitly even if the defaulted three-way comparison operator function is defined as deleted. &mdash;<i>end note</i>]
</blockquote>

<i>Drafting note: there can be more than one defaulted three-way comparison,
and we previously agreed to produce a defaulted <tt>operator==</tt> for each.
The old wording didn't specify many of the properties of the <tt>operator==</tt>
function; inheriting them all from the <tt>operator&lt;=&gt;</tt> function
seems like the right default behavior.</i>

<p>
Change heading of 11.11.2 [class.eq]: Equality operator<del>s</del>
</p>

<p>
Change in 11.11.2 [class.eq] paragraph 2:
</p>

<blockquote>
A defaulted <tt>==</tt> operator function
for a class <tt>C</tt> is defined as deleted unless,
for each <tt>x</tt><sub>i</sub> in the expanded list of subobjects
for an object <tt>x</tt> of type <tt>C</tt>,
<ins>overload resolution for</ins>
<tt>x</tt><sub>i</sub> <tt>==</tt> <tt>x</tt><sub>i</sub>
<ins>results in a usable candidate with return type</ins>
<del>is a valid expression and contextually convertible to</del>
<tt>bool</tt>.
</blockquote>

<i>Drafting note: if we want to allow conversions on the return type,
we need to decide which kinds we want.
We don't have a notion corresponding to "implicit conversion sequence" for direct-initialization,
so we'd need something at least a little inventive here.
Restricting to exactly <tt>bool</tt> (as we did for rewritten <tt>!=</tt>)
seems like the simplest and most consistent path forward.</i>

<p>
Delete 11.11.2 [class.eq] paragraph 4:
</p>

<blockquote class="stddel">
A defaulted != operator function for a class C with parameters x and y is defined as deleted if
<ul>
<li> overload resolution (12.4), as applied to x == y, does not result in a usable function, or
<li> x == y is not a prvalue of type bool.
</ul>
Otherwise, the operator function yields !(x == y).
</blockquote>

<p>
Change in 11.11.2 [class.eq] paragraph 5:
</p>

<blockquote>
<pre>
struct D {
  int i;
  friend bool operator==(const D& x, const D& y) = default; // OK, returns x.i == y.i
  <del>bool operator!=(const D& z) const = default; // OK, returns !(*this == z)</del>
};
</pre>
</blockquote>

<i>Drafting note: <tt>!=</tt> is handled with all the other secondary operators.</i>

<p>
Change in 11.11.3 [class.spaceship] paragraph 1:
</p>

<blockquote>
[...]
<ul>
<li>If overload resolution for <tt>a &lt;=&gt; b</tt> results in a usable <del>function</del> <ins>candidate</ins> (12.4), <tt>static_cast&lt;R&gt;(a &lt;=&gt; b)</tt>.
<li>Otherwise, if overload resolution for <tt>a &lt;=&gt; b</tt> finds at least one viable candidate, the synthesized
three-way comparison is not defined.
<li><ins>Otherwise, if <tt>R</tt> is not a comparison category type, or
if overload resolution for either the expression <tt>a == b</tt> or the expression <tt>a &lt; b</tt>
does not result in a usable candidate with return type <tt>bool</tt>,
the synthesized three-way comparison is not defined.</ins>
<li>[...]
<li>Otherwise<del>, if</del> <ins>(when</ins> <tt>R</tt> is <tt>partial_ordering</tt><ins>)</ins>, <del>then</del> [...]
<li><del>Otherwise, the synthesized three-way comparison is not defined.</del>
</ul>
[<i>Note</i>: A synthesized three-way comparison may be ill-formed if overload resolution finds usable <del>functions</del> <ins>candidates</ins>
that do not otherwise meet the requirements implied by the defined expression. &mdash;<i>end note</i>]
</blockquote>

<i>Drafting note: a built-in candidate is not a function, but must be considered here.</i>

<p>
Change in 11.11.3 [class.spaceship] paragraph 2:
</p>

<blockquote>
Let R be the declared return type of a defaulted three-way comparison operator function<del>.
Given</del>
<ins>, and let <tt>x</tt><sub>i</sub> be</ins> an expanded list of subobjects for an object x of type C<del>,
let R<sub>i</sub> be the type of the expression x<sub>i</sub> &lt;=&gt; x<sub>i</sub>,
or void if overload resolution applied to that expression does not find a usable function</del>.
<ul>
<li>
If R is auto, then
<ins>
let <tt>R</tt><sub>i</sub> be the type of the expression <tt>x</tt><sub>i</sub> <tt>&lt;=&gt;</tt> <tt>x</tt><sub>i</sub>.
The operator function is defined as deleted if overload resolution applied to that expression
does not find a usable candidate or if <tt>R</tt><sub>i</sub> is not a comparison category type ([cmp.categories.pre] 17.11.2.1).
The</ins>
<del>the</del> return type is deduced as the common comparison type (see below) of R<sub>0</sub>, R<sub>1</sub>, &hellip;, R<sub>n-1</sub>.
<del>If the return type is deduced as void, the operator function is defined as deleted.</del>

<li>
Otherwise, if the synthesized three-way comparison of type R between any objects xi and xi is not
defined <del>or would be ill-formed</del>, the operator function is defined as deleted.
</ul>
</blockquote>

<p>
Change in 11.11.3 [class.spaceship] paragraph 4:
</p>

<blockquote>
The common comparison type U of a possibly-empty list of n <ins>comparison category</ins> types T<sub>0</sub>, T<sub>1</sub>, &hellip;, T<sub>n-1</sub> is defined as follows:
<ul>
<li><del>If any Ti is not a comparison category type (17.11.2), U is void.</del>
<li><del> Otherwise, if</del> <ins>If</ins> at least one Ti is std::partial_ordering, U is std::partial_ordering (17.11.2.2).
<li>[...]
</ul>
</blockquote>

<i>Drafting note: producing <tt>void</tt> here is a hack that exists
to produce some answer from <tt>std::common_comparison_category</tt>,
and should be localized to that trait.</i>

<p>
Change heading of 11.11.4 [class.rel]: <del>Relational</del> <ins>Secondary comparison</ins> operators
</p>

<p>
Change in 11.11.4 [class.rel] paragraph 1:
</p>

<blockquote>
<ins>A <i>secondary comparison operator</i> is a relational operator ([expr.rel]) or the <tt>!=</tt> operator.</ins>
A defaulted <del>relational</del> operator function (12.6.2) for <del>some</del> <ins>a secondary comparison</ins> operator <tt>@</tt>
shall have a declared return type <tt>bool</tt>.
</blockquote>

<p>
Change in 11.11.4 [class.rel] paragraph 2:
</p>

<blockquote>
The operator function with parameters x and y is defined as deleted if
<ul>
<li>overload resolution (12.4), as applied to <tt>x <del>&lt;=&gt;</del> <ins>@</ins> y</tt>, does not result in a usable <del>function</del> <ins>candidate</ins>, or
<li>the <ins>candidate selected by overload resolution is not a rewritten candidate</ins> <del>operator @ cannot be applied to the return type of x &lt;=&gt; y</del>.
</ul>
Otherwise, the operator function yields <tt>x <del>&lt;=&gt;</del> <ins>@</ins> y <del>@ 0</del></tt>.
</blockquote>

<p>
Change in 12.4 [over.match] paragraph 4:
</p>

<blockquote>
Overload resolution results in a <i>usable <del>function</del> <ins>candidate</ins></i>
if overload resolution succeeds and the selected <ins>candidate is either not a</ins>
function <ins>([over.built]), or is a function that</ins>
is not deleted and is accessible from the context in which overload resolution was performed.
</blockquote>

<p>
Change in 14.5 [except.spec] paragraph 11:
</p>

<blockquote>
The exception specification for a comparison operator function (12.6.2) without a noexcept-specifier that
is defaulted on its first declaration is potentially-throwing if and only if <del>the invocation of any
comparison operator</del> <ins>any expression</ins> in the implicit definition is potentially-throwing.
</blockquote>

<i>Drafting note: the implicit definition can invoke other functions, such as a conversion from
some custom comparison category to the return type. Considering those is consistent with
the rule we use for defaulted special member functions.</i>

<p>
Change in 14.5 [except.spec] paragraph 13:
</p>

<blockquote>
An exception specification is considered to be <i>needed</i> when:
<ul>
<li>[&hellip;]
<li>the exception specification is needed for a defaulted <del>special member</del>
function that calls the function. [<i>Note</i>: &hellip;]
</ul>
The exception specification of a defaulted <del>special member</del> function
is evaluated as described above only when needed;
similarly, the <i>noexcept-specifier</i> of a specialization
of a function template or member function of a class template
is instantiated only when needed.
</blockquote>

<p>
Change in 17.11.3 [cmp.common] paragraph 2:
<p>

<blockquote>
<i>Remarks</i>
The member <i>typedef-name</i> <tt>type</tt> denotes the common comparison type (11.11.3) of
<tt>Ts...</tt>, the expanded parameter pack<ins>,
or <tt>void</tt> if any element of <tt>Ts</tt> is not a comparison category type</ins>.
[<i>Note</i>: This is <del>well-defined even</del> <ins><tt>std::strong_ordering</tt></ins>
if the expansion is empty<del> or includes a
type that is not a comparison category type</del>. &mdash;<i>end note</i>]
</blockquote>

<i>Drafting note: <tt>common_comparison_category</tt> should probably be removed.
The same functionality can be obtained using <tt>common_type</tt>,
except the latter is more general and SFINAE-friendly.</i>

</body></html>
