<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Core Issue 1776: Replacement of class objects containing reference members</title>

<style type="text/css">
  ins, ins * { text-decoration:none; font-weight:bold; background-color:#A0FFA0 }
  del, del * { text-decoration:line-through; background-color:#FFA0A0 }
  #hidedel:checked ~ * del, #hidedel:checked ~ * del * { display:none; visibility:hidden }

blockquote { color: #000000; background-color: #F1F1F1;
  border: 1px solid #D1D1D1;
  padding-left: 0.5em; padding-right: 0.5em; }
blockquote.stdins { text-decoration: underline;
  color: #000000; background-color: #C8FFC8;
  border: 1px solid #B3EBB3; padding: 0.5em; }
blockquote.stddel { text-decoration: line-through;
  color: #000000; background-color: #FFEBFF;
  border: 1px solid #ECD7EC;
  padding-left: 0.5empadding-right: 0.5em; ; }
</style>

</head>

<body>
Richard Smith<br>
2014-11-21

<h1>Core Issue 1776: Replacement of class objects containing reference members</h1>

<input type="checkbox" id="hidedel">Hide deleted text</input>

<!-- TODO

  for standard-layout struct and for union, a cast from a pointer to the object to a pointer to the first (or respectively, any) member type should give a pointer to that member, and this should apply recursively

  see two emails with additional comments

-->

<p>
Change in 1.8 (intro.object) paragraph 1:
</p>

<blockquote>
The constructs in a C++
program create, destroy, refer to, access, and manipulate objects.
<ins>
An <em>object</em> is created by a <em>definition</em> (3.1), by a <em>new-expression</em> (5.3.4)
or by the implementation (12.2) when needed.
</ins>
An <del><em>object</em> is</del><ins>object occupies</ins> a region of storage <ins>throughout its lifetime (3.8 basic.life)</ins>.
[&nbsp;<em>Note</em>:
A function is not an object, regardless of whether or not it occupies storage in the
way that objects do.
&mdash;&nbsp;<em>end note</em>&nbsp;]
<del>
An object is created by a <em>definition</em> (3.1), by a <em>new-expression</em> (5.3.4)
or by the implementation (12.2) when needed.
</del>
[&hellip;]
</blockquote>

<p>
Change in 1.8 (intro.object) paragraph 6:
</p>

<blockquote>
Unless an object is a bit-field or a base class subobject of zero size,
the address of that object is the address of the first byte it occupies.
Two objects <ins>with overlapping lifetimes</ins> that are not bit-fields
may have the same address if one is a subobject of the other,
or if at least one is a base class subobject of zero size and they are of different types;
otherwise, they shall have distinct addresses. [Footnote: &hellip;] [Example: &hellip;]
</blockquote>

<p>
Change in 3.7.4.1 (basic.stc.dynamic.allocation) paragraph 2:
</p>

<blockquote>
[&hellip;]
Furthermore, for the library allocation functions in 18.6.1.1 and
18.6.1.2, p0 shall <del>point to</del> <ins>represent the address of</ins>
a block of storage disjoint from the storage for
any other object accessible to the caller. The effect of indirecting through a
pointer returned as a request for zero size is undefined.
</blockquote>

<p>
Change in 3.8 (basic.life) paragraph 5:
</p>

<blockquote>
Before the lifetime of an object has started but after the storage which the object will occupy has been allocated [Footnote: &hellip;] or,
after the lifetime of an object has ended and before the storage which the object occupied is reused or released,
any pointer that <del>refers to</del> <ins>represents the address of</ins> the storage location
where the object will be or was located may be used but only in limited ways.
[&hellip;]
</blockquote>

<p>
Change in 3.8 (basic.life) paragraph 9:
</p>

<blockquote>
Creating a new object at the storage location that a const <ins>complete</ins> object with static<del>,</del> <ins>or</ins> thread<del>, or automatic</del> storage
duration occupies or<del>,</del> at the storage location that such a const object used to occupy before its lifetime
ended results in undefined behavior. [Example: &hellip;]
</blockquote>

<em>This is necessary to allow types such as <tt>std::optional</tt> to contain const subobjects; the existing restriction exists to allow ROMability, and so only affects complete objects and is not necessary for automatic storage duration objects.</em>

<p>
Change in 3.9.2 (basic.compound) paragraph 3:
</p>

<blockquote>
[&hellip;]
<ins>A value of an object pointer type <i>cv</i> <tt>T*</tt> either:
<ul><li><em>points to</em> an object of a type similar to <tt>T</tt>, or
    <li><em>points past the end of</em> an object of a type similar to <tt>T</tt> (5.3.1 expr.unary.op), or
    <li>is the <em>null pointer value</em> (4.10 conv.ptr) for that type, or
    <li>is an <em>invalid pointer value</em>.
</ul>
</ins>
A <del>valid</del> value of an object pointer type <ins>that is not a null pointer value</ins> <del>represents either
the address</del> <ins><em>represents the address</em></ins> of a byte in memory (1.7 intro.memory) <del>or a null pointer (4.10)</del>.
<del>
If an object of type T is located at an address A, a pointer of type cv T* whose value is the
address A is said to point to that object, regardless of how the value was obtained.
[&nbsp;<em>Note</em>:
For instance, the address one past the end of an array (5.7) would be considered to point to an unrelated object of the
array's element type that might be located at that address. There are further restrictions on pointers to
objects with dynamic storage duration; see 3.7.4.3.
&mdash;&nbsp;<em>end note</em>&nbsp;]</del>
<ins>For purposes of pointer arithmetic (5.7 expr.add) and comparison (5.9 expr.rel, 5.10 expr.eq),
a pointer that points past the end the last element of an array of <i>n</i> elements is considered
to point to a hypothetical element <i>n</i>.</ins>
The value representation of pointer types is implementation-defined.
[&hellip;]
</blockquote>

<p>
Change in 5.7 (expr.add) paragraph 4:
</p>

<blockquote>
When an expression that has integral type is added to or subtracted from a pointer,
the result has the type of the pointer operand.

<del>
If the pointer operand points to an element of an array object [Footnote],
and the array is large enough,
the result points to an element offset from the original element
such that the difference of the subscripts
of the resulting and original array elements
equals the integral expression.

In other words, if
</del><ins>If</ins>
the expression <tt>P</tt>
points to <del>the <em>i</em>-th</del> element <ins><i>i</i></ins>
of an array object <ins>with <em>n</em> elements
[&nbsp;<i>Footnote</i>:
An object that is not an array element is considered to belong to a single-element array for this purpose; see 5.3.1.
A pointer past the end of the last element of an array of <i>n</i> elements
is considered to point to a hypothetical element <i>n</i> for this purpose; see 3.9.2.
]</ins>,
the expressions

<del><tt>(P)+N</tt> (equivalently, <tt>N+(P)</tt>) and <tt>(P)-N</tt></del>

<ins><tt>P + <ins>J</ins></tt> and <tt>J + P</tt></ins>

(where <tt><del>N</del><ins>J</ins></tt> has the value <i><del>n</del><ins>j</ins></i>)
point to<del>, respectively, the</del>
<ins>element</ins> <em>i + j</em><del>-th and <em>i - n</em>-th elements</del>
of the array object
<del>, provided they exist</del>
<ins>if 0 &lt; <em>i + j</em> &lt; <em>n</em>,
and point past the last element of the array object if <em>i + j</em> = <em>n</em></ins><del>
Moreover, if the expression P points to the last element of an array object,
the expression (P)+1 points one past the last element of the array object, and if the expression Q points
one past the last element of an array object, the expression (Q)-1 points to the last element of the array
object. If both the pointer operand and the result point to elements of the same array object, or one past
the last element of the array object, the evaluation shall not produce an overflow</del>; otherwise, the behavior is
undefined.

<ins>Likewise, the expression <tt>P - J</tt> points to element <i>i - j</i> of the array object
if 0 &lt; <em>i - j</em> &lt; <em>n</em>,
and point past the last element of the array object if <em>i - j</em> = <em>n</em>; otherwise, the behavior is undefined.
</ins>
</blockquote>

<p>
Change in 5.7 (expr.add) paragraph 5:
</p>

<blockquote>
When two pointers to elements of the same array object are subtracted,
<del>
the result is the difference of the subscripts of the two array elements.
The</del> <ins>the</ins>
type of the result is an implementation-defined signed integral type;
this type shall be the same type that is defined as <tt>std::ptrdiff_t</tt> in the <tt>&lt;cstddef></tt> header (18.2).
<del>
As with any other arithmetic overflow, if the result does not fit in the space provided, the behavior is undefined.
In other words, if
</del> <ins>If</ins>
the expressions <tt>P</tt> and <tt>Q</tt> point to, respectively,
<del>the i-th and j-th</del> elements <ins><i>i</i> and <i>j</i></ins> of <del>an</del><ins>the same</ins> array object,
the expression <del>(P)-(Q)</del><ins>P - Q</ins> has the value <i>i - j</i>
<del>provided the value fits in an object of type <tt>std::ptrdiff_t</tt>.</del>
<ins>; otherwise, the behavior is undefined.
[&nbsp;<em>Note</em>:
If the value <i>i - j</i> is not in the range of representable values of type <tt>std::ptrdiff_t</tt>, the behavior is undefined.
&mdash;&nbsp;<em>end note</em>&nbsp;]</ins>
<del>
Moreover, if the expression P points either to an element of an array object or one past the last element of
an array object, and the expression Q points to the last element of the same array object, the expression
((Q)+1)-(P) has the same value as ((Q)-(P))+1 and as -((P)-((Q)+1)), and has the value zero if the
expression P points one past the last element of the array object, even though the expression (Q)+1 does not
point to an element of the array object. Unless both pointers point to elements of the same array object, or
one past the last element of the array object, the behavior is undefined.
[Footnote: Another way to approach pointer arithmetic &hellip;]
</del>
</blockquote>

<p>
Convert 5.7 (expr.add) paragraph 7 to a note:
</p>

<blockquote>
<ins>[&nbsp;<em>Note</em>:</ins>
If the value 0 is added to or subtracted from a pointer value, the result compares equal to the original pointer
value. If two pointers point to the same object or both point <del>one</del> past the end of the <ins>last element of the</ins> same array or both
are null, and the two pointers are subtracted, the result compares equal to the value 0 converted to the type
<tt>std::ptrdiff_t.</tt>
<ins>&mdash;&nbsp;<em>end note</em>&nbsp;]</ins>
</blockquote>

<p>
Change in 5.9 (expr.rel) paragraph 3:
</p>

<blockquote>
Comparing pointers to objects
[&nbsp;<i>Footnote</i>:
An object that is not an array element is considered to belong to a single-element array for this purpose; see 5.3.1.
<ins>
A pointer past the end of the last element of an array of <i>n</i> elements
is considered to point to a hypothetical element <i>n</i> for this purpose; see 3.9.2.
</ins>
]
is defined as follows:
<ul>
<li>If two pointers point to different elements of the same array, or to subobjects thereof, the pointer to
the element with the higher subscript compares greater.
<li><del>If one pointer points to an element of an array, or to a subobject thereof, and another pointer points
one past the last element of the array, the latter pointer compares greater.</del>
<li>
If two pointers point to different non-static data members of the same object, or to subobjects of such
members, recursively, the pointer to the later declared member compares greater provided the two
members have the same access control (Clause 11) and provided their class is not a union.
</ul>
</blockquote>

<em>Drafting note: the above change affects the semantics of an example like:</em>

  <pre>
  struct S {
    char a;
    int b;
  } s;
  static_assert(static_cast<void*>(&s.b) >= static_cast<void*>(&s.a + 1));</pre>

<em>Prior to this change, the result of the comparison was unspecified; now, it is required to hold, because <tt>&s.a + 1</tt> is treated as a pointer to an element of the "array" <tt>s.a</tt>. The value of <tt>&s.b > &s.a + 1</tt> is now specified and is <tt>false</tt> if and only if the pointers represent the same address.</em>

<p>
Add to 18.6 (support.dynamic) paragraph 1:
</p>

<blockquote class="stdins"><pre>
namespace std {
  template &lt;typename T>
    constexpr T* launder(T* p) noexcept;
}
</pre></blockquote>

<p>
Add a new subclause under 18.6 (support.dynamic):
</p>

<blockquote class="stdins">
  <pre>template &lt;typename T> constexpr T* launder(T* p) noexcept;</pre>

<p><em>Required behavior:</em> An invocation of this function may be used in core constant expressions whenever the value of its argument may be used in a core constant expression.
<p><em>Requires:</em> <tt>p</tt> represents the address <tt>A</tt> of a byte in memory, and an object <tt>O</tt> that is within its lifetime and whose cv-unqualified type is similar to <tt>T</tt> is located at the address <tt>A</tt>.
<p><em>Returns:</em> A value of type <tt>T *</tt> which points to <tt>O</tt>.
</blockquote>

<p>
Change in 20.7.5 (ptr.align) paragraph 1:
</p>

<blockquote>
<i>Effects:</i>
If it is possible to fit <tt>size</tt> bytes of storage aligned by <tt>alignment</tt> into the buffer pointed to by
<tt>ptr</tt> with length <tt>space</tt>, the function updates <tt>ptr</tt> to
<del>point to</del> <ins>represent</ins> the first possible
address of such storage and decreases <tt>space</tt> by the number of bytes
used for alignment.
</blockquote>

<p>
Change in 20.7.5 (ptr.align) paragraph 2:
</p>

<blockquote>
<i>Requires:</i>
<ul><li><tt>alignment</tt> shall be a power of two
    <li><tt>ptr</tt> shall <del>point to</del><ins>represent the address of</ins> contiguous storage of at least <tt>space</tt> bytes
</ul>
</blockquote>

</body></html>
