<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Core Issue XXXX: Base class copy and move constructors should not be inherited</title>

<style type="text/css">
  ins, ins > * { text-decoration:none; font-weight:bold; background-color:#A0FFA0 }
  del, del > * { text-decoration:line-through; background-color:#FFA0A0 }
</style>

</head>

<body>
Richard Smith<br>
2017-01-12

<h1>Core Issue XXXX: Base class copy and move constructors should not be inherited</h1>

<p>
Change in [over.match.funcs]p8:
</p>

<blockquote>
A defaulted move constructor or assignment operator (12.8)
that is defined as deleted
is excluded from the set of candidate functions in all contexts.
<ins>
A constructor inherited from class type <tt>C</tt> (12.6.3 [class.inhctor.init])
that has a first parameter of type "reference to <tt>P</tt>"
(including such a constructor instantiated from a template)
is excluded from the set of candidate functions
when constructing an object of type <i>cv</i> <tt>D</tt>
if the argument list has exactly one argument
and <tt>D</tt> is reference-related to <tt>P</tt>
and <tt>P</tt> is reference-related to <tt>C</tt>.
<!--
An inherited constructor
has a first parameter of type &quot;reference to <i>cv</i> <tt>C</tt>&quot;
(including such a constructor instantiated from a template)
is excluded from the set of candidate functions
when used to construct an object of type <tt>D</tt>
with an argument list containing a single argument
if <tt>C</tt> is reference-related to <tt>D</tt>.
====
<p>
Add a new paragraph after [over.best.ics]p4 (before "For the case where the
parameter type is a reference"):
</p>

<blockquote>
<ins>
If the target is the first parameter
of an inherited constructor (12.6.3 [class.inhctor.init])
first declared in class type <tt>C</tt>
with an argument list that has exactly one expression,
an implicit conversion sequence cannot be formed
if <tt>C</tt> is reference-related to
the type that the argument would have
after the application of the user-defined conversion (if any)
and before the final standard conversion sequence.
-->
[&nbsp;<em>Example</em>:
<pre>
struct A {
  A();
  A(A &amp;&amp;);                       // #1
  template&lt;typename T&gt; A(T &amp;&amp;);  // #2
};
struct B : A {
  using A::A;
  B(const B &amp;);       // #3
  B(B &amp;&amp;) = default;  // #4, implicitly deleted

  struct X { X(X &amp;&amp;) = delete; } x;
};
extern B b1;
B b2 = static_cast&lt;B&amp;&amp;&gt;(b1); // calls #3: #1, #2, and #4 are not viable
struct C { operator B&amp;&amp;(); };
B b3 = C(); // calls #3
</pre>
&mdash; <em>end example</em>&nbsp;]
</ins>
</blockquote>

</body></html>
